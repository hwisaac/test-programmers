## 문제 설명
최빈값은 주어진 값 중에서 가장 자주 나오는 값을 의미합니다. 정수 배열 array가 매개변수로 주어질 때, 최빈값을 return 하도록 solution 함수를 완성해보세요. 최빈값이 여러 개면 -1을 return 합니다.

## 제한사항
- 0 < array의 길이 < 100
- 0 ≤ array의 원소 < 1000

## 입출력 예
array |	result
---|---
[1, 2, 3, 3, 3, 4] |	3
[1, 1, 2, 2] |	-1
[1] |	1

## 입출력 예 설명
입출력 예 #1

- [1, 2, 3, 3, 3, 4]에서 1은 1개 2는 1개 3은 3개 4는 1개로 최빈값은 3입니다.

입출력 예 #2

- [1, 1, 2, 2]에서 1은 2개 2는 2개로 최빈값이 1, 2입니다. 최빈값이 여러 개이므로 -1을 return 합니다.

입출력 예 #3

- [1]에는 1만 있으므로 최빈값은 1입니다.

## 풀이

```js
function solution(array) {
  const frequency = new Map();

  // 각 숫자의 빈도를 계산하여 frequency Map에 저장
  for (let num of array) {
    if (frequency.has(num)) {
      frequency.set(num, frequency.get(num) + 1);
    } else {
      frequency.set(num, 1);
    }
  }

  let maxFrequency = 0;
  let mode = -1;

  // frequency Map을 순회하며 최빈값을 찾음
  for (let [num, count] of frequency) {
    if (count > maxFrequency) {
      maxFrequency = count;
      mode = num;
    } else if (count === maxFrequency) {
      // 최빈값이 여러 개인 경우 -1을 반환
      mode = -1;
    }
  }

  return mode;
}
```

이 코드는 `Map`을 사용하여 `frequency` 변수를 선언하고, `set()` 메서드를 사용하여 키와 값을 저장합니다. 또한 `for-of` 문을 사용하여 `Map`을 순회하고, `get()` 메서드를 사용하여 값을 가져옵니다. 이를 통해 빈도를 계산하고 최빈값을 구합니다.

딕셔너리 대신 `Map`을 사용하면 순서가 유지되므로 입력 배열에 있는 숫자의 등장 순서에 관계없이 정확한 최빈값을 구할 수 있습니다.


### {} 와 Map 의 차이

딕셔너리({})와 Map은 각각의 특징과 성능면에서 차이가 있습니다.

딕셔너리({}):

- 객체 리터럴로 구현된 딕셔너리는 JavaScript의 일부로서 널리 사용되는 데이터 구조입니다.
- 키-값 쌍을 저장하고, 키는 해시로 변환되어 내부 구조에 저장됩니다.
- 순서를 보장하지 않습니다.
- in 연산자를 사용하여 키의 존재 여부를 확인할 수 있습니다.
- 대부분의 경우에 빠른 접근 및 검색 성능을 제공합니다.
- 딕셔너리 크기에 비례하여 메모리 사용량이 증가합니다.

Map:

- ES6에서 추가된 내장 클래스로서, 순서가 보장되는 키-값 쌍의 컬렉션입니다.
- 키와 값은 삽입 순서대로 저장됩니다.
- has() 메서드를 사용하여 키의 존재 여부를 확인할 수 있습니다.
- 대부분의 경우 딕셔너리와 유사한 성능을 제공하지만, 특정 상황에서는 약간의 성능 저하가 있을 수 있습니다.
- 메모리 사용량이 딕셔너리보다 높을 수 있습니다.
- 딕셔너리와 Map은 각각의 특징과 성능을 가지고 있으며, 선택은 사용하는 상황과 요구 사항에 따라 달라집니다. 일반적으로 작은 크기의 데이터셋에서는 둘 사이의 성능 차이가 크게 나타나지 않을 수 있습니다. 그러나 대량의 데이터를 처리하거나 정렬이 필요한 경우에는 Map이 더 나은 선택일 수 있습니다.

딕셔너리({})는 JavaScript의 기본 데이터 구조로 많은 프로그래머들이 익숙하며, 성능도 우수합니다. 반면에 Map은 특정한 순서가 필요한 경우나 빈도 계산과 같은 작업에 유용합니다. 성능 차이는 상황에 따라 다를 수 있으므로 실제 데이터 크기와 작업 요구사항을 고려하여 적합한 선택을 할 수 있습니다.