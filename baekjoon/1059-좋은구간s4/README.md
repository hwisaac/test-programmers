## 문제

정수 집합 S가 주어졌을때, 다음 조건을 만족하는 구간 [A, B]를 좋은 구간이라고 한다.

- A와 B는 양의 정수이고, A < B를 만족한다.
- A ≤ x ≤ B를 만족하는 모든 정수 x가 집합 S에 속하지 않는다.

집합 S와 n이 주어졌을 때, n을 포함하는 좋은 구간의 개수를 구해보자.

## 입력

첫째 줄에 집합 S의 크기 L이 주어진다. 둘째 줄에는 집합에 포함된 정수가 주어진다. 셋째 줄에는 n이 주어진다.

## 출력

첫째 줄에 n을 포함하는 좋은 구간의 개수를 출력한다.

## 제한

- 1 ≤ L ≤ 50
- 집합 S에는 중복되는 정수가 없다.
- 집합 S에 포함된 모든 정수는 1보다 크거나 같고, 1,000보다 작거나 같다.
- 1 ≤ n ≤ (집합 S에서 가장 큰 정수)

## 예제 입력 1

```
4
1 7 14 10
2

```

## 예제 출력 1

```
4

```

> [2,3], [2,4], [2,5], [2, 6] : 총 4가지

## 예제 입력 2

```
5
4 8 13 24 30
10

```

## 예제 출력 2

```
5
```

> [9, 10], [9, 11], [9, 12], [10, 11], [10, 12] : 총 5가지

## 예제 입력 3

```
5
10 20 30 40 50
30

```

## 예제 출력 3

```
0

```

## 예제 입력 4

```
8
3 7 12 18 25 100 33 1000
59

```

## 예제 출력 4

```
1065

```

## 출처

- 문제를 번역한 사람: [baekjoon](https://www.acmicpc.net/user/baekjoon)

## 알고리즘 분류

- [수학](https://www.acmicpc.net/problem/tag/124)
- [브루트포스 알고리즘](https://www.acmicpc.net/problem/tag/125)
- [정렬](https://www.acmicpc.net/problem/tag/97)

## 풀이

```js
const filePath = process.platform === 'linux' ? 0 : './baekjoon/input.txt';

let input = require('fs').readFileSync(filePath).toString().trim().split('\n');

function goodIntervals(L, S, n) {
  S.sort((a, b) => a - b); // 정렬

  // n이 집합 S에 있으면 좋은 구간이 존재할 수 없음
  if (S.includes(n)) {
    return 0;
  }

  // 좌, 우측 '좋은 구간'을 위한 변수들
  let left = 0;
  let right = S[0];
  let count = 0;

  // 집합 S의 각 원소에 대해 좋은 구간을 계산
  for (let i = 0; i < L; i++) {
    right = S[i];

    // n이 현재 구간에 있을 경우 좋은 구간을 찾음
    if (left < n && n < right) {
      count += (n - left) * (right - n) - 1;
    }

    left = right;
  }

  right = 1001;
  if (left < n && n < right) {
    // 마지막 구간에 n이 있을 경우
    count += (n - left) * (right - n) - 1;
  }

  return count;
}

const L = parseInt(input[0]); //?
const S = input[1].split(' ').map(Number); //?
const n = parseInt(input[2]); //?

const result = goodIntervals(L, S, n);
console.log(result);

```

이 코드는 "좋은 구간"을 찾기 위한 알고리즘을 사용합니다. 좋은 구간이란, 주어진 숫자 `n`이 포함되며 그 구간에 속한 다른 모든 숫자들이 집합 `S`에 속하지 않는 구간을 의미합니다.

알고리즘은 다음과 같이 작동합니다:

1. 우선 집합 `S`를 정렬합니다. 이렇게 하면 집합 `S`의 원소들 사이의 구간을 쉽게 찾을 수 있습니다.

2. `n`이 집합 `S`에 이미 포함되어 있는지 확인합니다. 만약 포함되어 있다면, '좋은 구간'은 존재할 수 없으므로 결과는 `0`이 됩니다.

3. n이 집합 `S`에 포함되지 않는 경우, 각 연속하는 두 원소 사이에서 '좋은 구간'을 찾습니다. 이는 `S`의 원소들과 `n` 사이에 존재하는 구간을 의미합니다. 구간의 시작과 끝을 찾기 위해, `left`와 `right`라는 두 변수를 사용합니다. 각 `S`의 원소들을 순회하면서 `left`와 `right` 사이에 `n`이 존재하면, 해당 구간이 '좋은 구간'이라는 것을 알 수 있습니다.

4. '좋은 구간'에 대해 좌측 경계(`left`)부터 `n`까지의 거리와 `n`부터 우측 경계(`right`)까지의 거리를 곱하고 1을 빼줍니다. 이렇게 하면 해당 구간에서 '좋은 구간'의 개수를 구할 수 있습니다. 왜냐하면 **A ≤ x ≤ B**에서 `A`, `B`가 좋은 구간이 되려면 `x`가 `n`이어야 하며, 좌측 경계와 우측 경계 사이에 있는 다른 모든 숫자들은 집합 `S`에 속하지 않아야 하기 때문입니다.

5. 모든 '좋은 구간'의 개수를 합산하여 반환합니다.

위 알고리즘을 통해 `n`을 포함하는 '좋은 구간'의 개수를 효율적으로 찾을 수 있습니다. 이 문제의 경우, 시간 복잡도는 주어진 집합 `S`의 크기에 비례하므로, `O(L)`입니다.