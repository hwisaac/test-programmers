# BFS

너비우선탐색(BFS, Breadth-First Search)은 그래프나 트리에서 노드를 탐색하는 알고리즘 중 하나입니다. BFS는 너비(레벨)를 기준으로 노드를 탐색하는 방법으로, 같은 레벨에 있는 노드들을 먼저 탐색한 후 그 다음 레벨로 이동합니다.

BFS의 동작 방식은 다음과 같습니다:

1. 탐색을 시작할 노드를 큐에 넣고, 해당 노드를 방문한 것으로 표시합니다.
2. 큐가 비어있지 않은 동안 다음을 반복합니다:
   - 큐에서 노드를 추출합니다(처음에는 시작 노드).
   - 추출한 노드를 방문하거나 데이터를 수집합니다.
   - 추출한 노드의 이웃 노드 중 방문하지 않은 노드를 큐에 추가하고, 해당 노드를 방문한 것으로 표시합니다.
3. 큐가 비어있을 때까지 반복합니다.

BFS는 레벨 순서대로 탐색하기 때문에, 같은 레벨에 있는 노드들을 먼저 탐색하고 다음 레벨로 넘어갑니다. 이를 통해 너비우선 탐색이라고 불립니다.

BFS의 특징과 활용 사례는 다음과 같습니다:

- 최단 경로 탐색: 가중치가 없는 그래프에서 BFS는 출발 노드로부터 다른 노드까지의 최단 경로를 찾는 데 활용됩니다.
- 그래프 순회: BFS를 사용하여 그래프의 모든 노드를 탐색하고 연결 관계를 확인할 수 있습니다.
- 레벨 기반 문제 해결: 트리나 그래프의 레벨별로 문제를 해결할 때 유용합니다.
- 상태 공간 탐색: 상태 공간에서 특정 조건을 충족하는 상태를 찾는 문제에서 BFS는 가능한 모든 상태를 탐색하는 데 사용될 수 있습니다.

BFS는 큐를 사용하여 구현되며, 모든 노드를 한 번씩 방문하기 때문에 시간 복잡도는 O(V + E)입니다. 여기서 V는 노드의 수, E는 간선의 수입니다.

BFS는 너비우선 탐색의 특성상 최단 경로를 찾거나 그래프의 구조를 파악하는 등의 다양한 문제에 유용하게 활용될 수 있는 중요한 알고리즘입니다.

# DFS

깊이우선탐색(DFS, Depth-First Search)은 그래프나 트리에서 노드를 탐색하는 알고리즘 중 하나입니다. DFS는 한 경로를 따라 최대한 깊숙히 탐색한 후, 더 이상 진행할 수 없을 때 다음 분기로 돌아와 다른 경로를 탐색합니다.

DFS의 동작 방식은 다음과 같습니다:

1. 탐색을 시작할 노드를 선택합니다.
2. 현재 노드를 방문한 것으로 표시합니다.
3. 현재 노드와 연결된 이웃 노드 중 방문하지 않은 노드를 임의로 선택합니다.
4. 선택한 이웃 노드로 이동하여 해당 노드를 현재 노드로 설정하고, 2번부터 다시 진행합니다.
5. 만약 더 이상 방문하지 않은 이웃 노드가 없다면, 이전 노드로 되돌아갑니다.
6. 이전 노드로 되돌아간 후, 다른 방문하지 않은 이웃 노드를 선택하여 4번부터 반복합니다.
7. 모든 노드를 방문할 때까지 위 과정을 반복합니다.

DFS는 스택(Stack) 또는 **재귀 함수**를 사용하여 구현될 수 있습니다. 스택을 사용하는 경우 현재 노드와 이웃 노드들을 스택에 저장하고, 재귀 함수를 사용하는 경우 현재 노드를 함수의 매개변수로 전달하고 재귀 호출을 수행합니다.

DFS의 특징과 활용 사례는 다음과 같습니다:

- 그래프 순회: DFS를 사용하여 그래프의 모든 노드를 탐색하고 연결 관계를 확인할 수 있습니다.
- 사이클 탐지: DFS는 그래프에서 사이클의 존재 여부를 확인하는 데 사용될 수 있습니다.
- 백트래킹: DFS는 제약 조건이 있는 문제에서 해를 찾기 위해 가능한 모든 경로를 탐색하거나, 최적의 해를 찾을 때 사용될 수 있습니다.
- 미로 찾기: DFS를 사용하여 미로에서 출발지에서 목적지까지 경로를 탐색할 수 있습니다.
- 연결 요소 확인: DFS를 사용하여 그래프의 연결 요소를 확인할 수 있습니다.
DFS의 시간 복잡도는 그래프의 모든 노드와 간선을 탐색하기 때문에 O(V + E)입니다. 여기서 V는 노드의 수, E는 간선의 수입니다. 재귀 호출을 사용하는 경우, 재귀 깊이가 최대 노드 수에 비례하므로 스택 사용과 관련된 추가적인 메모리가 필요할 수 있습니다.

DFS는 깊이우선탐색의 특성상 그래프 구조를 파악하는 데 유용하며, 백트래킹이 필요한 문제나 연결 요소 확인과 같은 문제 해결에 사용될 수 있습니다.

# BFS 와 DFS 의 차이

DFS와 BFS는 그래프나 트리에서 노드를 탐색하는 알고리즘입니다. 이들 간에는 몇 가지 차이점이 있습니다.

1. 탐색 순서:

- DFS: 한 경로를 따라 최대한 깊숙히 탐색한 후, 다른 경로로 이동합니다.
- BFS: 너비(레벨)를 기준으로 노드를 탐색합니다. 같은 레벨에 있는 노드들을 먼저 탐색한 후 다음 레벨로 이동합니다.

2. 탐색 방식:
- DFS: 스택(Stack) 또는 재귀 함수를 사용하여 구현할 수 있습니다. 한 경로를 따라 가능한 멀리 진행하기 때문에 메모리 사용이 적습니다.
- BFS: 큐(Queue)를 사용하여 구현할 수 있습니다. 너비우선 탐색을 수행하므로, 각 레벨의 모든 노드를 탐색하는 것이 필요하므로 메모리 사용이 더 많을 수 있습니다.

3. 탐색 결과:
- DFS: 경로 상에서 목표 노드를 빨리 찾을 수 있습니다. 따라서 경로 길이가 중요한 문제에서 유용합니다. 하지만 최단 경로를 보장하지는 않습니다.
- BFS: 출발 노드로부터 목표 노드까지의 최단 경로를 보장합니다. 최단 경로 탐색에 적합한 알고리즘입니다.
어떤 탐색 알고리즘이 좋은지는 문제의 특성과 요구 사항에 따라 다릅니다.

DFS는 메모리 사용이 적고, 목표 노드가 깊은 레벨에 있거나 경로 길이가 중요한 경우에 유용합니다. 또한 백트래킹이 필요한 경우에도 사용될 수 있습니다.
BFS는 최단 경로를 찾는 문제에 적합합니다. 모든 레벨을 순차적으로 탐색하므로, 너비우선 순서로 탐색해야 하는 경우 유용합니다.
따라서 DFS와 BFS 중 어느 것이 더 좋은지는 문제의 성격과 요구 사항에 따라 다르며, 상황에 맞게 선택해야 합니다. 최단 경로를 찾거나 모든 노드를 순차적으로 탐색해야 하는 경우 BFS가 유용하며, 경로 길이가 중요하지 않거나 깊은 레벨에서 목표를 찾는 것이 중요한 경우 DFS가 적합할 수 있습니다.

> 깊이보다 너비가 넓은 트리의 경우 DFS 가 더 적은 메모리를 점유합니다.

## DFS 에서 검색순서 pre-order vs in-order vs post-order

DFS에서 검색 순서인 pre-order, in-order, post-order는 트리의 노드를 방문하는 순서를 정의합니다. 각각의 순서는 트리의 구조와 어떤 정보를 찾고자 하는지에 따라 선택됩니다.

1. Pre-order (전위 순서):

- 노드 방문 순서: 현재 노드 → 왼쪽 서브트리 → 오른쪽 서브트리
- 주로 사용되는 경우:
  - 트리의 구조를 복원하거나 복사하는 등의 작업에서 사용됩니다.
  - 트리의 전체 구조를 빠르게 탐색하고자 할 때 사용될 수 있습니다.
- 예시: 이진 트리의 전체 구조를 출력하는 경우에 유용합니다.

1. In-order (중위 순서):
- 노드 방문 순서: 왼쪽 서브트리 → 현재 노드 → 오른쪽 서브트리
- 주로 사용되는 경우:
  - 이진 검색 트리에서 노드 값을 정렬된 순서로 방문하고자 할 때 사용됩니다.
  - 정렬된 값을 찾거나 출력하는 등의 작업에서 사용됩니다.
- 예시: 이진 검색 트리에서 정렬된 값을 찾거나 출력하는 경우에 유용합니다.

1. Post-order (후위 순서):

- 노드 방문 순서: 왼쪽 서브트리 → 오른쪽 서브트리 → 현재 노드
- 주로 사용되는 경우:
  - 트리의 리프 노드부터 시작하여 특정 동작을 수행하고자 할 때 사용됩니다.
  - 트리의 리프에서부터 상위 노드로 정보를 수집하거나 특정 연산을 수행하는 등의 작업에서 사용됩니다.
- 예시: 이진 트리의 리프에서부터 거리를 계산하거나 리프 노드의 값을 합산하는 경우에 유용합니다.

어떤 순서를 선택해야 할지는 주어진 문제에 따라 다릅니다. 예를 들어, 트리의 구조를 복원하려는 경우 Pre-order 순서를 사용할 수 있고, 이진 검색 트리에서 값을 정렬된 순서로 찾고자 하는 경우 In-order 순서를 사용할 수 있습니다. 특정 동작을 리프 노드에서부터 수행하거나 정보를 수집해야 하는 경우 Post-order 순서를 선택할 수 있습니다.

따라서 어떤 순서를 선택해야 할지는 주어진 문제와 요구 사항에 따라 다르며, 상황에 맞게 선택해야 합니다.