문제 설명
수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다.

1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ...
2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, ...
3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, ...

1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 solution 함수를 작성해주세요.

제한 조건
시험은 최대 10,000 문제로 구성되어있습니다.
문제의 정답은 1, 2, 3, 4, 5중 하나입니다.
가장 높은 점수를 받은 사람이 여럿일 경우, return하는 값을 오름차순 정렬해주세요.
입출력 예
answers	return
[1,2,3,4,5]	[1]
[1,3,2,4,2]	[1,2,3]
입출력 예 설명
입출력 예 #1

수포자 1은 모든 문제를 맞혔습니다.
수포자 2는 모든 문제를 틀렸습니다.
수포자 3은 모든 문제를 틀렸습니다.
따라서 가장 문제를 많이 맞힌 사람은 수포자 1입니다.

입출력 예 #2

모든 사람이 2문제씩을 맞췄습니다.

## 내 풀이
```js
function solution(answers) {
  var answer = [];
  const counts = [0,0,0]
  
  
  answers.forEach(
       (x, index) => {
         if (x === student1(index) ) {
             counts[0] += 1
         }
       if (x === student2(index) ) {
             counts[1] += 1
         }
           if (x === student3(index) ) {
             counts[2] += 1
         }
       }
  )
  
  const max = Math.max(...counts)
  
  counts.forEach(  (c,index) => {
      if (c === max ){
          answer.push(index+1)
      }
  })
  
  return answer;
}

function student1 ( n ){
  return n%5 +1
}

function student2 ( n ){
  if (n % 2 === 0 ) return 2
  const arr = [1,3,4,5];
  const x = (n-1)/2 
  return arr[ x%4 ]   
}

function student3 (n ){
  const arr = [3,1,2,4,5] 
  console.log(arr) 
  if (n % 2 === 0 ) {  
      return arr[(n/2)%5]
  }
  return arr[ (n-1)/2 %5  ] 
}
```

이 코드의 주요 문제점은 가독성과 확장성에 있습니다.

- 가독성: 코드의 가독성이 좋지 않습니다. 함수명이나 변수명이 직관적이지 않아 코드를 이해하기 어렵습니다. 함수명과 변수명을 더 명확하게 지으면 코드를 이해하기 쉬워집니다. 또한, 함수 내에서 `if`문이 중첩되어 있어 코드의 복잡성이 증가합니다.

- 확장성: 현재 코드는 수포자의 패턴을 각각의 함수로 정의하고 있습니다. 하지만 문제에서는 수포자가 3명이지만, 더 많은 수포자가 추가될 수도 있다고 명시되어 있습니다. 현재 코드에서는 수포자 패턴을 추가하기 위해서는 새로운 함수를 작성해야 합니다. 이는 코드의 유지보수와 확장을 어렵게 만듭니다.

- 중복 코드: `answers` 배열을 순회하면서 각 수포자의 정답과 비교하는 부분에서 중복 코드가 발생합니다. 이 부분을 함수로 분리하거나 반복문을 활용해 중복을 제거할 수 있습니다.

- 최대값 탐색: 현재 코드에서는 Math.max(...counts)를 사용하여 가장 높은 점수를 찾고 있습니다. 하지만 이 방법은 최대값이 여러 개인 경우에 대한 처리가 필요합니다. 여러 명이 동일한 최고 점수를 받은 경우, 모두 결과에 포함되어야 합니다. 현재 코드에서는 이를 처리하지 못하고 있습니다.

아래는 개선된 코드의 예시입니다.

```javascript
function solution(answers) {
  const patterns = [
    [1, 2, 3, 4, 5],
    [2, 1, 2, 3, 2, 4, 2, 5],
    [3, 3, 1, 1, 2, 2, 4, 4, 5, 5]
  ];
  
  const scores = [0, 0, 0];
  
  answers.forEach((answer, index) => {
    patterns.forEach((pattern, personIndex) => {
      if (answer === pattern[index % pattern.length]) {
        scores[personIndex]++;
      }
    });
  });
  
  const maxScore = Math.max(...scores);
  
  const result = scores.reduce((acc, score, index) => {
    if (score === maxScore) {
      acc.push(index + 1);
    }
    return acc;
  }, []);
  
  return result;
}

// 테스트 예시
console.log(solution([1, 2, 3, 4, 5])); // [1]
console.log(solution([1, 3, 2, 4, 2])); // [1, 2, 3]

```

이 최적화된 솔루션은 다음과 같은 점들을 개선하였습니다.

1. 패턴 배열을 사용한 각 수포자의 찍기 패턴 정의: 각 수포자의 찍기 패턴을 2차원 배열로 정의하였습니다. 이를 통해 각 수포자의 찍기 패턴을 간결하게 표현할 수 있게 되었습니다.

2. 반복문을 활용한 정답 확인과 점수 계산: 반복문을 사용하여 주어진 정답과 찍기 패턴을 비교하고, 정답일 경우 해당 수포자의 점수를 증가시킵니다. 이를 통해 중첩된 반복문을 제거하고 각 수포자의 점수를 효율적으로 계산할 수 있게 되었습니다.

3. 최고 점수와 함께 결과 배열 생성: `reduce` 메소드를 활용하여 수포자들의 점수를 순회하며 최고 점수와 동일한 경우 해당 수포자의 인덱스를 결과 배열에 추가합니다. 이를 통해 반복문을 최소화하고 결과 배열을 생성할 수 있게 되었습니다.

이렇게 개선된 솔루션은 원래 코드보다 효율적이며 성능도 더 좋을 것입니다.